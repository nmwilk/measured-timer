package com.measuredsoftware.android.timer;

import android.app.Activity;
import android.app.AlarmManager;
import android.app.Notification;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.animation.Animation;
import android.view.animation.AnimationUtils;
import android.widget.TextView;

import com.measuredsoftware.android.timer.TimerView.OnEventListener;


public class TimerActivity extends Activity implements TimerView.OnEventListener {
  public static final String ALARM_ACTION         = "com.measuredsoftware.android.timer.ALARM";
  
  public static TimerActivity mCurrentActivity;
  
  public final static int DEFAULT_SCREEN_RES_X = 480;
  public final static int DEFAULT_SCREEN_RES_Y = 320;
  private static final String PREFS_LOC         = "measuredtimer";
  private static final String PREFS_VAL_ENDTIME = "endtime";
  private static final String INTENT_VAR_ALARM_RINGING = "alarmringing";
  
  private TextView mTVDigitalTime;
  private TimerView mDial;
  private View mCancelButton;
  private OnClickListener mCancelOnClickListener;
  
  private Animation mFadeInAnim;
  private Animation mFadeOutAnim;
  
  private TickThread mTickThread = null;
  
  private boolean mTimerRunning;
  private boolean mAlarmRinging;
  
  private NotificationManager mNotificationManager;
  
  private SharedPreferences mPrefs;
  private long              mSavedEndTime;
  
  public boolean mAtFront;
  
  private Handler mHandler = new Handler() {
    @Override
    public void handleMessage(Message msg) {
      long left = updateTimeInViews();
      if (left == 0 && mTimerRunning) {
        // TODO buzzer
        //doAlarm();
        Log.d("mtimer","got msg, left " + left);
      }
    }
  };
  
  /** Called when the activity is first created. */
  @Override
  public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    mCurrentActivity = this;
    mAtFront = false;

    setContentView(R.layout.main);
    
    mNotificationManager = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
    
    DisplayMetrics dm = new DisplayMetrics();
    getWindowManager().getDefaultDisplay().getMetrics(dm);
    
    int defaultWidth = DEFAULT_SCREEN_RES_X;
    int defaultHeight = DEFAULT_SCREEN_RES_Y;
    if (dm.widthPixels != defaultWidth) {
      float ratio =((float)dm.widthPixels) / dm.heightPixels;
      defaultWidth = (int)(defaultHeight * ratio);
    }        

    // create animations
    mFadeInAnim = AnimationUtils.loadAnimation(this, R.anim.fade_in);    
    mFadeOutAnim = AnimationUtils.loadAnimation(this, R.anim.fade_out);    

    mCancelButton = (TextView)findViewById(R.id.cancel_button);
    mCancelOnClickListener = new OnClickListener() {

      @Override
      public void onClick(View v) {
        mDial.setEndTime(0);
        updateTimeInViews();
        stopTimer();
      }
      
    };    
    mCancelButton.setOnClickListener(mCancelOnClickListener);
    
    mTVDigitalTime = (TextView)findViewById(R.id.digital_time);
    mTVDigitalTime.bringToFront();

    mDial          = (TimerView)findViewById(R.id.the_dial);
    mDial.setOnSetValueChangedListener(this);
    
    mTickThread = null;
    mTimerRunning = false;
    
    mPrefs = getSharedPreferences(PREFS_LOC, MODE_PRIVATE);
    mSavedEndTime = mPrefs.getLong(PREFS_VAL_ENDTIME, 0);
  }

  @Override
  protected void onDestroy() {
    super.onDestroy();
    mCurrentActivity = null;
  }

  @Override
  protected void onPause() {
    super.onPause();

    mAtFront = false;
    
    pauseThread();
  }

  @Override
  protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    
    mAlarmRinging = intent.getBooleanExtra(INTENT_VAR_ALARM_RINGING, false);
    Log.d("mtimer","onResume: alarmRinging " + mAlarmRinging);
  }

  @Override
  protected void onResume() {
    super.onResume();

    mAtFront = true;

    if (mSavedEndTime != 0 && mSavedEndTime > System.currentTimeMillis()) {
      // if there was a saved timer and it not expired, start it
      mDial.setEndTime(mSavedEndTime);
      startTickThread();
      showCancelButton();
      mTimerRunning = true;
    }
    
    updateTimeInViews();
    
    if (mAlarmRinging) {
      // TODO ring
      doAlarm();
    } 

    if (!mTimerRunning)
      hideCancelButton();
    
    if (mTickThread != null) {
      mTickThread.unpause();
    }
    
    mNotificationManager.cancel(1);
  }
  
  private void pauseThread() {
    if (mTickThread != null) {
      mTickThread.pause();
    }
  }

  @Override
  public void onEvent(int nResult, int value) {
    switch(nResult) {
      case OnEventListener.RESULT_VALUE_CHANGE:
        setDigitalTimeTo(value);
        break;
      case OnEventListener.RESULT_START:
        stopTickThread();
        startTickThread();
        showCancelButton();
        long endTime = mDial.getEndTime();
        writeTimeToPrefs(endTime);
        mTimerRunning = true;
        setupAlarm(endTime);
        break;
      case OnEventListener.RESULT_CANCEL:
        stopTimer();
        break;
    }
  }
  
  BroadcastReceiver theAlarmReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
      if (!intent.getAction().equals(ALARM_ACTION))
        return;
        //////

      // if we're not at the front, send notification
      if (!mAtFront) {
        int icon = R.drawable.icon;
        String tickerText = "New Alarm!";
        long when = System.currentTimeMillis();
  
        Intent i = new Intent(context, TimerActivity.class);
        i.putExtra(TimerActivity.INTENT_VAR_ALARM_RINGING, true);      
        PendingIntent launchIntent = PendingIntent.getActivity(context, 0, i, 0);
        
        Notification alarmNotification = new Notification(icon, tickerText, when);
        alarmNotification.setLatestEventInfo(context, context.getString(R.string.expanded_title), context.getString(R.string.expanded_text), launchIntent);
        alarmNotification.when = System.currentTimeMillis();
  
        String svcName = Context.NOTIFICATION_SERVICE;
        NotificationManager notificationManager;
        notificationManager = (NotificationManager)context.getSystemService(svcName);      
        notificationManager.notify(1, alarmNotification);   
      } else {
        doAlarm();
      }
    }
  };

  private void setupAlarm(long endTime) {
    AlarmManager alarmManager = (AlarmManager)getSystemService(ALARM_SERVICE);
    Intent i = new Intent(ALARM_ACTION);
    alarmManager.set(AlarmManager.RTC_WAKEUP, endTime, PendingIntent.getBroadcast(getApplicationContext(), 0, i, PendingIntent.FLAG_UPDATE_CURRENT));
    IntentFilter filter = new IntentFilter(ALARM_ACTION);
    registerReceiver(theAlarmReceiver, filter);
    Log.d("mtimer","alarm set for " + endTime);
  }
  
  private void writeTimeToPrefs(long endTime) {
    SharedPreferences.Editor editor = mPrefs.edit();
    editor.putLong(PREFS_VAL_ENDTIME, endTime);
    editor.commit();
  }

  private void stopTimer() {
    stopTickThread();
    mTimerRunning = false;
    writeTimeToPrefs(0);
    hideCancelButton();
  }
  
  private void stopTickThread() {
    if (mTickThread != null) {
      mTickThread.quit();
      mTickThread = null;
    }
  }
  
  public void doAlarm() {
    // TODO
    stopTimer();     
    mNotificationManager.cancel(1);
    Log.d("mtimer","ALARM!");
  }

  private void startTickThread() {
    mTickThread = new TickThread();
    mTickThread.start();
  }
  
  private void setDigitalTimeTo(int value) {
    mTVDigitalTime.setText(""+value);
    mTVDigitalTime.invalidate();
  }
  
  private void showCancelButton() {
    if (mCancelButton.getVisibility() != View.INVISIBLE)
      return;
    mCancelButton.startAnimation(mFadeInAnim);
    mCancelButton.setVisibility(View.VISIBLE);
  }

  private void hideCancelButton() {
    if (mCancelButton.getVisibility() != View.VISIBLE)
      return;
    mCancelButton.startAnimation(mFadeOutAnim);
    mCancelButton.setVisibility(View.INVISIBLE);    
  }

  private long updateTimeInViews() {
    long timeLeft = mDial.updateTime();
    mTVDigitalTime.setText(""+timeLeft);
    mTVDigitalTime.invalidate();
    mDial.invalidate();
    return timeLeft;
  }
  
  public class TickThread extends Thread {
    private boolean mRun; 
    private boolean mPaused; 
    
    @Override
    public void start() {
      mPaused = false;
      super.start();
    }
    
    @Override
    public void run() {
      mRun = true;
      mPaused = false;
      
      while(mRun) {
        try {
          sleep(200);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        
        if (!mPaused) {
          Log.d("mtimer","Thread: tick " + System.currentTimeMillis());
        
          mHandler.sendMessage(new Message());
        }
      }
    }
    
    public void quit() {
      mRun = false;
    }
    
    public void pause() {
      mPaused = true;
    }

    public void unpause() {
      mPaused = false;
    }
  }
}